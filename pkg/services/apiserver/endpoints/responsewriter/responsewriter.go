package transport

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"net"
	"net/http"

	"k8s.io/apiserver/pkg/endpoints/responsewriter"
)

var _ responsewriter.CloseNotifierFlusher = (*ResponseAdapter)(nil)
var _ responsewriter.UserProvidedDecorator = (*ResponseAdapter)(nil)

// ResponseAdapter is an implementation of [http.ResponseWriter] that allows conversion to a [http.Response].
type ResponseAdapter struct {
	ctx context.Context
	res *http.Response
	rw  *bufio.ReadWriter
}

// NewAdapter returns an initialized [ResponseAdapter].
func NewAdapter(ctx context.Context) *ResponseAdapter {
	r, w := io.Pipe()
	reader := bufio.NewReader(r)
	writer := bufio.NewWriter(w)
	rw := bufio.NewReadWriter(reader, writer)
	return &ResponseAdapter{
		ctx: ctx,
		res: &http.Response{
			Proto:      "HTTP/1.1",
			ProtoMajor: 1,
			ProtoMinor: 1,
			Header:     make(http.Header),
		},
		rw: rw,
	}
}

// Header implements [http.ResponseWriter].
// It returns the response headers to mutate within a handler.
func (ra *ResponseAdapter) Header() http.Header {
	return ra.res.Header
}

// Write implements [http.ResponseWriter].
func (ra *ResponseAdapter) Write(buf []byte) (int, error) {
	return ra.rw.Write(buf)
}

// WriteHeader implements [http.ResponseWriter].
func (ra *ResponseAdapter) WriteHeader(code int) {
	ra.res.StatusCode = code
	ra.res.Status = fmt.Sprintf("%03d %s", code, http.StatusText(code))
}

// Flush implements [http.Flusher].
func (ra *ResponseAdapter) Flush() {
	if err := ra.rw.Flush(); err != nil {
		// This should never happen, but if it does, we can't do anything about it.
		panic(fmt.Sprintf("error flushing response: %v", err))
	}
}

// Response returns the [http.Response] generated by the [http.Handler].
func (ra *ResponseAdapter) Response() *http.Response {
	ra.Flush()
	ra.res.Body = io.NopCloser(ra.rw)
	return ra.res
}

// Decorate implements [responsewriter.UserProvidedDecorator].
func (ra *ResponseAdapter) Unwrap() http.ResponseWriter {
	return ra
}

// CloseNotify implements [http.CloseNotifier].
func (ra *ResponseAdapter) CloseNotify() <-chan bool {
	ch := make(chan bool)
	go func() {
		<-ra.ctx.Done()
		ch <- true
	}()
	return ch
}

// Hijack implements [http.Hijacker].
func (ra *ResponseAdapter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	return nil, ra.rw, nil
}
